deprecated, buggy or stuff for future:

#--------------------------------------------------------------------
# raw_nano
#   Print the *nanosecond part of the current second* (0‑999999999)
#   exactly as produced by GNU date (+%N).  If %N is not supported,
#   compute the same value via kernel data, falling back to 0.
#
#   Return status:
#       0 – a genuine nanosecond value was produced
#       1 – we had to fall back to a placeholder (0)
#--------------------------------------------------------------------
raw_nano() {
    local ns

    # --------------------------------------------------------------
    # 1️⃣  Try native date %N
    # --------------------------------------------------------------
    ns=$(date +%N 2>/dev/null)
    if [[ $ns =~ ^[0-9]{9}$ ]]; then
        printf '%s\n' "$ns"
        return 0
    fi

    # --------------------------------------------------------------
    # 2️⃣  Compute nanoseconds of the *current* second ourselves:
    #     * boot time (seconds) from kern.boottime
    #     * monotonic nanosecond counter from IOHIDSystem (nanoseconds since boot)
    #     epoch_ns = boot_sec * 1e9 + idle_ns
    #     ns_of_sec = epoch_ns % 1e9
    # --------------------------------------------------------------
    local boot_sec idle_ns epoch_ns
    boot_sec=$(sysctl -n kern.boottime 2>/dev/null |
               awk -F'=' '/sec/ {gsub(/[ ,}]/,"",$2); print $2}')
    idle_ns=$(ioreg -c IOHIDSystem -r -d 1 2>/dev/null |
              awk -F' = ' '/HIDIdleTime/ {gsub(/[ ,}]/,"",$2); print $2}')

    if [[ -n $boot_sec && $boot_sec =~ ^[0-9]+$ &&
          -n $idle_ns && $idle_ns =~ ^[0-9]+$ ]]; then
        # epoch in nanoseconds (big integer arithmetic works in Bash arithmetic)
        epoch_ns=$(( boot_sec * 1000000000 + idle_ns ))
        # nanoseconds within the current second = epoch_ns modulo 1 000 000 000
        ns=$(( epoch_ns % 1000000000 ))
        # Zero‑pad to exactly nine digits (GNU date always does this)
        printf '%09d\n' "$ns"
        return 0
    fi

    # --------------------------------------------------------------
    # 3️⃣  Last‑ditch fallback – we cannot determine the real value.
    #     Return a safe placeholder (all zeroes) so callers still get a
    #     nine‑digit string.
    # --------------------------------------------------------------
    printf '000000000\n'
    return 1
}


# Interactive Demos
# TODO - fix expect script - not working on models that take long time to respond
#interactive=(
#  "./interactive.chat.sh"
#  "./interactive.generate.sh"
#)
#
#for demo in "${interactive[@]}"; do
#  outfile_md=$(echo "$demo" | sed 's/\.sh$/.md/g')
#  echo "Expect: $demo > $outfile_md"
#  (
#    expect <<EOF
#      spawn $demo
#      expect "\r>>> "
#      send "The secret word is RABBIT. Understand?\r"
#      sleep 20
#      expect "\r>>> "
#      send "3 words describing Bash\r"
#      sleep 20
#      expect "\r>>> "
#      send "What is the secret word?\r"
#      sleep 20
#      expect "\r>>> "
#      send "\003"
#      expect eof
#EOF
#  ) > "$outfile_md" 2>&1
#done

# Escape control characters in a string
# Keep the surrounding JSON syntax unchanged (braces, quotes, commas, etc)
#
# Usage: _escape_control_characters "string"
# Input  : 1 - any Bash string – it may already be a JSON fragment.
# Output : the same fragment, but every control byte (U+0000‑U+001F
#          and DEL) is turned into a JSON‑legal escape:
#            * \b, \t, \n, \f, \r for the five most common controls
#            * \u00XX for any other control character
#          Printable / UTF‑8 bytes are emitted unchanged.
# Requires: none
# Returns: 0
_DEPRECATED_escape_control_characters() {
  if (( OLLAMA_LIB_SAFE_MODE != 1 )); then # If Safe Mode is OFF, do not escape control characters
    printf '%s' "$1"
    return 0
  fi
  # @ai-assist gpt-oss:120b
  _debug "_escape_control_characters: [${1:0:120}]"
  local input="$1"
  local out='' # accumulator for the escaped result
  # Feed the exact bytes of $input to od – one decimal number per
  # byte (no address column, unsigned, never squeeze repeats).
  while IFS= read -r line; do
    set -- "$line" # split the od line into numbers
    for b in "$@"; do
      if (( b >= 0 && b <= 31 )) || (( b == 127 )); then # Control characters (U+0000‑U+001F and DEL)
        case $b in
          8)  out+="\\b" ;; # backspace
          9)  out+="\\t" ;; # horizontal tab
          10) out+="\\n" ;; # line feed (LF)
          12) out+="\\f" ;; # form‑feed
          13) out+="\\r" ;; # carriage‑return
          *) out+="$(printf '\\u%04x' "$b")" ;; # any other control → \u00XX
        esac
      else # Printable / UTF‑8 bytes – copy them unchanged
        #    Build a one‑byte variable that contains the raw byte.
        #    printf '\\%03o' produces a back‑slash‑octal escape,
        #    which we then expand with %b (only octal is expanded,
        #    not the \u escapes we added above).
        printf -v chr '\\%03o' "$b"
        out+="$(printf '%b' "$chr")"
      fi
    done
  done < <(printf '%s' "$input" | od -An -tuC -v)
  _debug "_escape_control_characters: out: [${out:0:120}]"
  printf '%s' "$out" # print the accumulator
}

# Escape control characters in a string, leaving surrounding JSON syntax
# unchanged.  Returns the escaped string on stdout.
#
#   _escape_control_characters "some string"
#
# If OLLAMA_LIB_SAFE_MODE is 1, bytes 0‑31 and 127 are turned into JSON‑legal
# escapes:
#   * \b, \t, \n, \f, \r for the five most common controls
#   * \u00XX for any other control character
# Printable / UTF‑8 bytes are emitted unchanged.
_escape_control_characters() {
  # --------------------------------------------------------------
  # 1️⃣  Safe‑mode shortcut – when safe‑mode is OFF we simply echo the
  #      original argument unchanged.
  # --------------------------------------------------------------
  if (( OLLAMA_LIB_SAFE_MODE != 1 )); then   # safe‑mode OFF → no escaping
    printf '%s' "$1"
    return 0
  fi

  _debug "_escape_control_characters: [${1:0:120}]"

  local input="${1}"
  local out=''                # accumulator for the escaped result

  # --------------------------------------------------------------
  # 2️⃣  Turn the input into a stream of *decimal* byte values,
  #      one per line.
  #
  #    od -An -tuC -v   → unsigned decimal bytes, no address column,
  #                       never squeeze repeats.
  #    tr -s ' ' '\n'   → replace every space with a newline.
  #    The first space in od’s output creates a blank line; we will
  #    ignore any line that does **not** consist solely of digits.
  # --------------------------------------------------------------
  while IFS= read -r b; do
    # Keep only lines that are pure numbers (skip blank lines and any
    # stray whitespace that may have survived the tr command).
    [[ $b =~ ^[0-9]+$ ]] || continue

    # --------------------------------------------------------------
    # 3️⃣  Is the byte a control character (U+0000‑U+001F or DEL)?
    # --------------------------------------------------------------
    if (( b >= 0 && b <= 31 )) || (( b == 127 )); then
      case $b in
        8)  out+='\\b' ;;               # backspace
        9)  out+='\\t' ;;               # horizontal tab
        10) out+='\\n' ;;               # line feed (LF)
        12) out+='\\f' ;;               # form‑feed
        13) out+='\\r' ;;               # carriage‑return
        *) out+="$(printf '\\u%04x' "$b")" ;;   # any other control → \u00XX
      esac
    else
      # ------------------------------------------------------------
      # 4️⃣  Printable / UTF‑8 byte – copy unchanged.
      #
      #    Build a one‑byte string with an octal escape and then expand
      #    it with %b.  %b expands *only* octal escapes, leaving the \u
      #    sequences we added above untouched.
      # ------------------------------------------------------------
      printf -v chr '\\%03o' "$b"
      out+="$(printf '%b' "$chr")"
    fi
  done < <(printf '%s' "$input" | od -An -tuC -v | tr -s ' ' '\n')

  _debug "_escape_control_characters: out: [${out:0:120}]"
  printf '%s' "$out"
}